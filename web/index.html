<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Minimalisp (WebAssembly)</title>
    <style>
      body {
        font-family: 'Fira Mono', 'SFMono-Regular', Consolas, monospace;
        background: #1e1e1e;
        color: #f0f0f0;
        margin: 0;
        padding: 1rem;
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-gap: 1rem;
        height: 100vh;
        box-sizing: border-box;
      }
      .column { display: flex; flex-direction: column; gap: 1rem; }
      h1, h2 { margin: 0; }
      .console {
        background: #111;
        border: 1px solid #333;
        height: 280px;
        overflow-y: auto;
        padding: 0.5rem;
      }
      .console-line { white-space: pre-wrap; margin: 0.1rem 0; }
      .console-line.input { color: #7ee787; }
      .console-line.result { color: #79c0ff; }
      .console-line.error { color: #ff6b6b; }
      .console-line.info { color: #fbc02d; }
      textarea {
        width: 100%;
        height: 6rem;
        resize: vertical;
        background: #0d1117;
        color: #e6edf3;
        border: 1px solid #30363d;
        padding: 0.5rem;
        box-sizing: border-box;
      }
      button, select, label { font-size: 0.9rem; }
      button {
        background: #238636;
        color: #fff;
        border: none;
        padding: 0.4rem 0.9rem;
        cursor: pointer;
      }
      button.secondary { background: #444; }
      button:disabled { opacity: 0.6; cursor: not-allowed; }
      canvas { width: 100%; height: 220px; border: 1px solid #333; background: #000; }
      .toolbar, .viz-toolbar { display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; }
      #legend span { margin-right: 1rem; }
    </style>
  </head>
  <body>
    <div class="column">
      <div>
        <h1>Minimalisp WASM Playground</h1>
        <p>Shift+Enter inserts a newline. Press Enter or the Run button to evaluate in the embedded interpreter.</p>
      </div>
      <div class="console" id="replLog"></div>
      <textarea id="replInput" spellcheck="false">(print (+ 1 2 3))</textarea>
      <div class="toolbar">
        <button id="runBtn">Run</button>
        <label>GC Backend:
          <select id="backend">
            <option value="mark-sweep">mark-sweep</option>
            <option value="copying">copying</option>
            <option value="generational">generational</option>
          </select>
        </label>
        <span class="hint">(Changing backend after execution requires a reload.)</span>
      </div>
    </div>
    <div class="column">
      <h2>Heap Visualization</h2>
      <div class="viz-toolbar">
        <label><input type="checkbox" id="autoSnapshot" checked /> Auto snapshot</label>
        <button id="snapshotBtn" class="secondary">Snapshot now</button>
      </div>
      <canvas id="heapCanvas" width="640" height="220"></canvas>
      <div id="legend">
        <span style="color:#6cf">Number</span>
        <span style="color:#fc3">Symbol</span>
        <span style="color:#6f6">Pair</span>
        <span style="color:#f69">Lambda</span>
        <span style="color:#f33">Env</span>
        <span style="color:#f93">Binding</span>
        <span style="color:#9cf">String</span>
      </div>
      <p>The canvas maps the WASM linear memory, highlighting allocated objects. Copying/Generational GC compact nursery objects; mark-sweep tends to fragment over time.</p>
    </div>
    <script src="interpreter.js"></script>
    <script>
      const replLog = document.getElementById('replLog');
      const replInput = document.getElementById('replInput');
      const runBtn = document.getElementById('runBtn');
      const backendSelect = document.getElementById('backend');
      const autoSnapshotCheckbox = document.getElementById('autoSnapshot');
      const snapshotBtn = document.getElementById('snapshotBtn');
      const canvas = document.getElementById('heapCanvas');
      const ctx = canvas.getContext('2d');

      const TAG_COLORS = {
        0: '#444',
        1: '#6cf',
        2: '#fc3',
        3: '#6f6',
        4: '#f69',
        5: '#c6f',
        10: '#f33',
        11: '#f93',
        12: '#9cf'
      };

      let evalFunc;
      let backendSetter;
      let snapshotFunc;
      let infoPtr = 0;
      const snapshotCapacity = 2048; // entries
      let backendLocked = false;
      let currentBackend = backendSelect.value;
      let autoSnapshotTimer = null;

      function logLine(text, type = 'output') {
        const div = document.createElement('div');
        div.className = `console-line ${type}`;
        div.textContent = text;
        replLog.appendChild(div);
        replLog.scrollTop = replLog.scrollHeight;
      }

      function initHeapBuffer() {
        if (infoPtr === 0) {
          infoPtr = Module._malloc(snapshotCapacity * 4 * 4);
        }
      }

      function drawHeap(data, count) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const totalBytes = Module.HEAPU8.length;
        for (let i = 0; i < count; i++) {
          const base = i * 4;
          const addr = data[base];
          const size = data[base + 1];
          const generation = data[base + 2];
          const tag = data[base + 3];
          const color = TAG_COLORS[tag] || '#888';
          const x = ((addr % totalBytes) / totalBytes) * canvas.width;
          const width = Math.max(1, (size / totalBytes) * canvas.width);
          const y = generation === 1 ? 30 : generation === 2 ? 120 : 180;
          ctx.fillStyle = color;
          ctx.fillRect(x, y, width, 24);
        }
      }

      function snapshotHeap() {
        if (!snapshotFunc) return;
        initHeapBuffer();
        const heapView = new Uint32Array(Module.HEAPU32.buffer, infoPtr, snapshotCapacity * 4);
        const count = snapshotFunc(infoPtr, snapshotCapacity);
        drawHeap(heapView, count);
      }

      function updateAutoSnapshot() {
        if (autoSnapshotTimer) {
          clearInterval(autoSnapshotTimer);
          autoSnapshotTimer = null;
        }
        if (autoSnapshotCheckbox.checked) {
          autoSnapshotTimer = setInterval(snapshotHeap, 600);
        }
      }

      function ensureBackendSelected() {
        if (!backendSetter) return;
        if (!backendLocked) {
          backendSetter(backendSelect.value);
          backendLocked = true;
          currentBackend = backendSelect.value;
        }
      }

      function runProgram() {
        const code = replInput.value.trim();
        if (!code) return;
        logLine('ml> ' + code, 'input');
        replInput.value = '';
        try {
          ensureBackendSelected();
          const result = evalFunc(code);
          logLine(String(result), 'result');
        } catch (err) {
          logLine(String(err), 'error');
        }
        snapshotHeap();
      }

      Module['onRuntimeInitialized'] = () => {
        Module.print = (text) => logLine(text, 'output');
        Module.printErr = (text) => logLine(text, 'error');
        evalFunc = Module.cwrap('eval', 'string', ['string']);
        snapshotFunc = Module.cwrap('gc_heap_snapshot', 'number', ['number', 'number']);
        backendSetter = Module.cwrap('gc_set_backend_env', null, ['string']);
        backendSetter(currentBackend);

        logLine('Minimalisp ready. Shift+Enter inserts newline; Enter runs the code.', 'info');

        runBtn.addEventListener('click', runProgram);
        replInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            runProgram();
          }
        });

        backendSelect.addEventListener('change', () => {
          if (backendLocked && backendSelect.value !== currentBackend) {
            logLine('Reload the page to switch GC backend mid-session.', 'info');
            backendSelect.value = currentBackend;
            return;
          }
          currentBackend = backendSelect.value;
          backendSetter(currentBackend);
        });

        snapshotBtn.addEventListener('click', snapshotHeap);
        autoSnapshotCheckbox.addEventListener('change', updateAutoSnapshot);
        updateAutoSnapshot();
        snapshotHeap();
      };
    </script>
  </body>
</html>
